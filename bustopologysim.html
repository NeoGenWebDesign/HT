<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bus Network Topology Simulator</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Consolas', 'Courier New', monospace;
            background: linear-gradient(180deg, #353636 50%, #032a36 75%);
            min-height: 100vh;
        }
        a {
            display: block;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            text-align: center;
        }
        .container-card {
            background-color: white;
            border-radius: 1rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -4px rgba(0, 0, 0, 0.05);
            padding: 2rem;
        }
        .vis-area {
            position: relative;
            height: 300px;
            width: 100%;
            border-radius: 0.75rem;
            background-color: #fff;
            margin-bottom: 1.5rem;
        }
        .node {
            position: absolute;
            width: 60px;
            height: 60px;
            background-color: #3b82f6; /* Blue for Nodes */
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.9rem;
            font-weight: bold;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            transition: background-color 0.3s, transform 0.3s;
            z-index: 10;
            cursor: pointer;
        }
        .node:hover {
            transform: scale(1.05);
        }
        .selected-source {
            background-color: #f59e0b; /* Amber */
            box-shadow: 0 0 15px #f59e0b;
        }
        .selected-target {
            background-color: #10b981; /* Emerald Green */
            box-shadow: 0 0 15px #10b981;
        }
        .bus-line {
            position: absolute;
            height: 8px;
            background-color: #4b5563; /* Dark Gray Backbone */
            width: 90%;
            left: 5%;
            top: 50%;
            transform: translateY(-50%);
            border-radius: 4px;
            z-index: 5;
        }
        .drop-cable {
            position: absolute;
            width: 4px;
            background-color: #4b5563;
            height: 50px;
            top: 50%;
            transform: translateY(0);
            z-index: 6;
        }
        .packet {
            position: absolute;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background-color: #ef4444; /* Red for data */
            z-index: 20;
            transition: transform linear;
            box-shadow: 0 0 8px #ef4444;
        }
        .collision-flash {
            animation: flash 0.1s infinite alternate;
        }
        @keyframes flash {
            from { background-color: #fca5a5; }
            to { background-color: #ef4444; }
        }
        .console-log {
            min-height: 200px;
            background-color: #1f2937;
            color: #d1d5db;
            font-family: 'Consolas', 'Courier New', monospace;
            border-radius: 0.5rem;
            padding: 1rem;
            overflow-y: auto;
            white-space: pre-wrap;
            font-size: 0.85rem;
        }
        .log-send { color: #f59e0b; } /* Amber */
        .log-accept { color: #34d399; } /* Light Green */
        .log-reject { color: #9ca3af; } /* Gray */
        .log-collision { color: #ef4444; font-weight: bold; } /* Red */
        .log-info { color: #facc15; } /* Yellow */
    </style>
</head>
<body class="p-4 md:p-10 min-h-screen">

    <div class="max-w-4xl mx-auto">
        <h1 class="text-4xl font-extrabold text-orange-500 mb-2 text-center">
            Bus Network Topology Simulation
        </h1>
        <p class="text-lg text-white mb-6 text-center">
            Simulating data transmission across a shared backbone cable.
        </p>
        <p class="text-sm text-yellow-500 mb-8 text-center">
            Press F5 or Reload/Refresh Browser to Reset Simulation.
        </p>
        <a id="link" class="text-sm hover:text-lime-500 text-yellow-200 mb-8 text-center" href="index.html">
            Back to Simulations Index
        </a>

        <div class="container-card">
            <p class="text-gray-700 mb-4 text-sm">
                [Image of Bus Network Topology]
                In a Bus Topology, every device is connected to a single central cable, the **Backbone**. Data sent by any node travels across the entire backbone, meaning it is a **shared medium**. This architecture requires protocols like CSMA/CD to manage access and prevent simultaneous transmission, known as a **Collision**.
            </p>
            
            <div id="bus-vis" class="vis-area">
                <!-- Visualization elements will be injected here -->
            </div>

            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
                <div class="bg-gray-100 p-3 rounded-lg flex flex-col justify-center">
                    <label class="text-sm font-medium text-gray-700 mb-1">Source Node:</label>
                    <select id="source-select" class="p-2 border border-gray-300 rounded-md"></select>
                </div>
                <div class="bg-gray-100 p-3 rounded-lg flex flex-col justify-center">
                    <label class="text-sm font-medium text-gray-700 mb-1">Target Node:</label>
                    <select id="target-select" class="p-2 border border-gray-300 rounded-md"></select>
                </div>
                
                <div class="flex flex-col gap-2">
                    <button onclick="simulateTransmission()" id="send-btn"
                            class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-lg shadow-md transition duration-150 text-center text-sm disabled:opacity-50">
                        Start Transmission (CSMA/CD)
                    </button>
                    <button onclick="simulateCollision()" id="collide-btn"
                            class="bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-4 rounded-lg shadow-md transition duration-150 text-center text-sm disabled:opacity-50">
                        Simulate Collision
                    </button>
                </div>
            </div>

            <h3 class="text-xl font-semibold text-gray-800 mb-3">Network Console Log</h3>
            <div id="bus-log" class="console-log">
                <p class="log-info">Network is initialized. Select Source and Target nodes above, then click 'Start Transmission'.</p>
            </div>
        </div>
    </div>

    <script>
        const NODE_IDS = ['A', 'B', 'C', 'D', 'E'];
        const DURATION_MS = 1500;
        const PACKET_SPEED = 0.5; // pixels per ms
        const NODE_Y = 150; // Y coordinate for all nodes
        let animationLocked = false;
        
        let nodePositions = {}; // Stores calculated X coordinates for each node
        let busWidth = 0;
        let busLeft = 0;

        // --- Utility Functions ---

        /** Logs a message to the console element */
        function log(message, type = 'log-info') {
            const consoleEl = document.getElementById('bus-log');
            const timestamp = new Date().toLocaleTimeString('en-US', { hour12: false, second: '2-digit', minute: '2-digit' });
            consoleEl.innerHTML += `[${timestamp}] <span class="${type}">${message}</span>\n`;
            consoleEl.scrollTop = consoleEl.scrollHeight;
        }

        /** Clears the visualization container and calculates node positions */
        function initializeVisualization() {
            const container = document.getElementById('bus-vis');
            container.innerHTML = '';
            
            const { width } = container.getBoundingClientRect();
            busWidth = width * 0.9;
            busLeft = width * 0.05;

            // 1. Draw the Bus Line (Backbone)
            const busLine = document.createElement('div');
            busLine.className = 'bus-line';
            container.appendChild(busLine);
            
            // Calculate and draw nodes
            const spacing = busWidth / (NODE_IDS.length + 1);
            
            NODE_IDS.forEach((id, index) => {
                // Calculate position relative to the container, centered on the bus line
                const x = busLeft + spacing * (index + 1); 
                
                nodePositions[id] = x;
                
                // Draw Node
                const node = document.createElement('div');
                node.className = 'node';
                node.id = `node-${id}`;
                node.style.left = `${x - 30}px`; // Centered
                node.style.top = `${NODE_Y - 80}px`; // Above the bus line
                node.textContent = id;
                node.onclick = () => selectNode(id);
                container.appendChild(node);
                
                // Draw Drop Cable connection
                const dropCable = document.createElement('div');
                dropCable.className = 'drop-cable';
                dropCable.style.left = `${x - 2}px`;
                dropCable.style.top = `${NODE_Y - 30}px`;
                dropCable.style.height = `38px`;
                container.appendChild(dropCable);
            });
            
            populateSelects();
        }

        /** Populates the source and target dropdowns */
        function populateSelects() {
            const sourceSelect = document.getElementById('source-select');
            const targetSelect = document.getElementById('target-select');

            sourceSelect.innerHTML = '';
            targetSelect.innerHTML = '';

            NODE_IDS.forEach(id => {
                const sourceOption = new Option(`Node ${id}`, id);
                const targetOption = new Option(`Node ${id}`, id);
                sourceSelect.add(sourceOption);
                targetSelect.add(targetOption);
            });

            // Set default selections
            sourceSelect.value = 'A';
            targetSelect.value = 'E';
            updateSelectedNodes();
            
            // Add change listeners
            sourceSelect.onchange = updateSelectedNodes;
            targetSelect.onchange = updateSelectedNodes;
        }

        /** Updates the visual style of the selected nodes */
        function updateSelectedNodes() {
            const sourceId = document.getElementById('source-select').value;
            const targetId = document.getElementById('target-select').value;

            document.querySelectorAll('.node').forEach(node => {
                node.classList.remove('selected-source', 'selected-target');
                if (node.id === `node-${sourceId}`) {
                    node.classList.add('selected-source');
                } else if (node.id === `node-${targetId}`) {
                    node.classList.add('selected-target');
                }
            });
        }
        
        /** Allows clicking a node to set it as source */
        function selectNode(id) {
            const sourceSelect = document.getElementById('source-select');
            sourceSelect.value = id;
            updateSelectedNodes();
        }


        // --- Core Simulation Functions ---

        /** Simulates a single data transmission */
        async function simulateTransmission() {
            if (animationLocked) return;
            
            const sourceId = document.getElementById('source-select').value;
            let targetId = document.getElementById('target-select').value;
            
            if (sourceId === targetId) {
                targetId = NODE_IDS.find(id => id !== sourceId) || 'B';
                document.getElementById('target-select').value = targetId;
                updateSelectedNodes();
                log(`Source and Target were the same. Setting Target to ${targetId}.`, 'log-info');
            }

            animationLocked = true;
            document.querySelectorAll('button').forEach(btn => btn.disabled = true);
            
            const startX = nodePositions[sourceId];
            const targetX = nodePositions[targetId];

            log('-------------------------------------------', 'log-info');
            log(`START: Node ${sourceId} checks the medium and sends a packet intended for Node ${targetId}. (Shared Medium Access)`, 'log-send');

            // 1. Animate Packet Travel
            await transmitPacket(sourceId, targetId);

            // 2. Cleanup and unlock
            log(`END: Transmission complete. Medium free.`, 'log-info');
            animationLocked = false;
            document.querySelectorAll('button').forEach(btn => btn.disabled = false);
        }

        /** Handles the animation of a single packet across the bus */
        async function transmitPacket(sourceId, targetId, isCollision = false) {
            const container = document.getElementById('bus-vis');
            const startX = nodePositions[sourceId];
            const targetX = nodePositions[targetId];
            const busY = NODE_Y;

            // Packet 1: travels to the right
            const p1 = createPacket(startX, busY, isCollision ? 'collision-flash' : '');
            
            // Packet 2: travels to the left (starting from source position)
            const p2 = createPacket(startX, busY, isCollision ? 'collision-flash' : '');

            container.appendChild(p1);
            container.appendChild(p2);

            const travelDuration = busWidth / PACKET_SPEED;

            // Animate to the right (to end of bus)
            const rightMove = busLeft + busWidth - startX;
            const rightDuration = rightMove / PACKET_SPEED;
            p1.style.transitionDuration = `${rightDuration}ms`;
            p1.style.transform = `translateX(${rightMove}px)`;

            // Animate to the left (to start of bus)
            const leftMove = busLeft - startX;
            const leftDuration = Math.abs(leftMove) / PACKET_SPEED;
            p2.style.transitionDuration = `${leftDuration}ms`;
            p2.style.transform = `translateX(${leftMove}px)`;


            // Check for reception at all nodes during travel
            const promises = NODE_IDS.map(id => {
                if (id !== sourceId) {
                    const nodeX = nodePositions[id];
                    const distance = Math.abs(nodeX - startX);
                    const delay = distance / PACKET_SPEED;
                    
                    return new Promise(resolve => {
                        setTimeout(() => {
                            const nodeEl = document.getElementById(`node-${id}`);
                            if (id === targetId && !isCollision) {
                                log(`Node ${id} detects packet address and ACCEPTS data.`, 'log-accept');
                                nodeEl.classList.add('ring-4', 'ring-green-400');
                                setTimeout(() => nodeEl.classList.remove('ring-4', 'ring-green-400'), 500);
                            } else if (!isCollision) {
                                log(`Node ${id} detects packet address and REJECTS data.`, 'log-reject');
                            }
                            resolve();
                        }, delay);
                    });
                }
                return Promise.resolve();
            });

            await Promise.all(promises);
            await new Promise(r => setTimeout(r, travelDuration));

            p1.remove();
            p2.remove();

            if (isCollision) {
                log('COLLISION DETECTED! All nodes cease transmission and wait a random backoff time.', 'log-collision');
                await new Promise(r => setTimeout(r, 1000));
            }
        }
        
        /** Simulates a collision between two nodes, D and B */
        async function simulateCollision() {
            if (animationLocked) return;
            animationLocked = true;
            document.querySelectorAll('button').forEach(btn => btn.disabled = true);

            log('-------------------------------------------', 'log-info');
            log('COLLISION SCENARIO: Node D and Node B attempt to transmit simultaneously.', 'log-collision');
            
            const startX_D = nodePositions['D'];
            const startX_B = nodePositions['B'];
            const busY = NODE_Y;
            const container = document.getElementById('bus-vis');

            // Packet 1 (from D): travels left
            const pD = createPacket(startX_D, busY, 'collision-flash bg-red-800');
            // Packet 2 (from B): travels right
            const pB = createPacket(startX_B, busY, 'collision-flash bg-red-800');
            
            container.appendChild(pD);
            container.appendChild(pB);
            
            // D sends left
            const leftMove_D = busLeft - startX_D;
            const duration_D = Math.abs(leftMove_D) / PACKET_SPEED;
            pD.style.transitionDuration = `${duration_D}ms`;
            pD.style.transform = `translateX(${leftMove_D}px)`;

            // B sends right
            const rightMove_B = busLeft + busWidth - startX_B;
            const duration_B = rightMove_B / PACKET_SPEED;
            pB.style.transitionDuration = `${duration_B}ms`;
            pB.style.transform = `translateX(${rightMove_B}px)`;
            
            // Calculate collision point (mid-way if durations were equal, but let's approximate)
            const collisionPoint = (startX_D + startX_B) / 2;
            
            // Collision happens when they meet. Duration until collision:
            const distanceBetween = Math.abs(startX_D - startX_B);
            const timeToCollision = (distanceBetween / (2 * PACKET_SPEED)) * 1.5; // Slightly longer for visual effect

            log(`Nodes D and B send signals. Collision expected at position: ${collisionPoint.toFixed(0)}px.`, 'log-collision');
            
            // Wait for collision time
            await new Promise(r => setTimeout(r, timeToCollision));
            
            // Collision Visual Effect (Jitter the packets)
            pD.style.transitionDuration = '0.1s';
            pB.style.transitionDuration = '0.1s';
            pD.style.transform = `translate(${pD.getBoundingClientRect().left - container.getBoundingClientRect().left - 9 + 5}px, ${busY - 9}px)`;
            pB.style.transform = `translate(${pB.getBoundingClientRect().left - container.getBoundingClientRect().left - 9 - 5}px, ${busY - 9}px)`;

            document.getElementById('node-D').classList.add('ring-4', 'ring-red-400', 'animate-pulse');
            document.getElementById('node-B').classList.add('ring-4', 'ring-red-400', 'animate-pulse');

            log('MEDIUM JAMMED! Nodes D and B detect the collision and send a JAM signal.', 'log-collision');

            await new Promise(r => setTimeout(r, 1500)); 
            
            pD.remove();
            pB.remove();
            document.getElementById('node-D').classList.remove('ring-4', 'ring-red-400', 'animate-pulse');
            document.getElementById('node-B').classList.remove('ring-4', 'ring-red-400', 'animate-pulse');
            
            log('The medium is clear. Nodes will now attempt re-transmission after a random backoff period.', 'log-info');
            
            animationLocked = false;
            document.querySelectorAll('button').forEach(btn => btn.disabled = false);
        }

        /** Creates the visual packet element */
        function createPacket(x, y, extraClasses = '') {
            const packet = document.createElement('div');
            packet.className = `packet absolute ${extraClasses}`;
            // Position the packet at the startX on the bus Y level
            packet.style.left = `${x - 9}px`; // Centered
            packet.style.top = `${y - 9}px`; // Centered on the bus line
            return packet;
        }

        // --- Event Listeners and Initial Setup ---
        
        window.addEventListener('load', initializeVisualization);
        window.addEventListener('resize', initializeVisualization);
    </script>
</body>
</html>