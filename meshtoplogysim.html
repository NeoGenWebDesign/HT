<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mesh Network Topology Simulator</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Consolas', 'Courier New', monospace;
            background: linear-gradient(180deg, #353636 50%, #032a36 75%);
            min-height: 100vh;
        }
        a {
            display: block;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            text-align: center;
        }
        .container-card {
            background-color: white;
            border-radius: 1rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -4px rgba(0, 0, 0, 0.05);
            padding: 2rem;
        }
        .vis-area {
            position: relative;
            height: 450px;
            width: 100%;
            border-radius: 0.75rem;
            background-color: #fff;
            margin-bottom: 1.5rem;
            overflow: hidden;
        }
        .node {
            position: absolute;
            width: 65px;
            height: 65px;
            background-color: #5e9605; /* Emerald Green for Mesh Nodes */
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.9rem;
            font-weight: bold;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            transition: background-color 0.3s, transform 0.3s;
            z-index: 10;
            cursor: pointer;
        }
        .node:hover {
            transform: scale(1.05);
        }
        .packet {
            position: absolute;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background-color: #3b82f6; /* Blue for data */
            z-index: 20;
            transition: all 0.5s ease-out; /* Slower, smoother movement */
            box-shadow: 0 0 8px #3b82f6;
        }
        .link {
            position: absolute;
            height: 2px;
            background-color: #9ca3af; /* Gray link path */
            transform-origin: 0 0;
            z-index: 5;
            transition: background-color 0.5s;
        }
        .link.broken {
            background-color: #dc2626 !important; /* Red for broken */
            box-shadow: 0 0 8px #ef4444;
        }
        .link.active {
            background-color: #3b82f6 !important; /* Blue when active */
        }
        .console-log {
            min-height: 200px;
            background-color: #1f2937;
            color: #d1d5db;
            font-family: 'Consolas', 'Courier New', monospace;
            border-radius: 0.5rem;
            padding: 1rem;
            overflow-y: auto;
            white-space: pre-wrap;
            font-size: 0.85rem;
        }
        .log-send { color: #3b82f6; } /* Blue */
        .log-route { color: #facc15; } /* Yellow */
        .log-accept { color: #34d399; } /* Light Green */
        .log-fail { color: #ef4444; font-weight: bold; } /* Red */
        .log-info { color: #93c5fd; } /* Light Blue */
    </style>
</head>
<body class="p-4 md:p-10 min-h-screen">

    <div class="max-w-4xl mx-auto">
        <h1 class="text-4xl font-extrabold text-orange-500 mb-2 text-center">
            Mesh Network Topology Simulator
        </h1>
        <p class="text-lg text-white mb-6 text-center">
            Simulating full-mesh connectivity, routing, and high fault tolerance.
        </p>
        <p class="text-sm text-yellow-500 mb-8 text-center">
            Press F5 or Reload/Refresh Browser to Reset Simulation.
        </p>
        <a id="link" class="text-sm hover:text-lime-500 text-yellow-200 mb-8 text-center" href="index.html">
            Back to Simulations Index
        </a>

        <div class="container-card">
            <p class="text-gray-700 mb-4 text-sm">
                [Image of Full Mesh Topology]
                In a Full Mesh Topology, every device is connected directly to every other device. This provides maximum redundancy and high reliabilityâ€”if one link fails, the data can simply be rerouted. The primary challenges are the high cost and complexity ($$n(n-1)/2$$ links for $$n$$ devices) and complex routing protocols. We will demonstrate how data uses the shortest path and how the network recovers from link failures.
            </p>
            
            <div id="mesh-vis" class="vis-area">
                <!-- Visualization elements will be injected here -->
            </div>

            <div class="grid grid-cols-1 md:grid-cols-4 gap-4 mb-6 items-end">
                <div class="bg-gray-100 p-3 rounded-lg flex flex-col justify-center">
                    <label class="text-sm font-medium text-gray-700 mb-1">Source Node:</label>
                    <select id="source-select" class="p-2 border border-gray-300 rounded-md"></select>
                </div>
                <div class="bg-gray-100 p-3 rounded-lg flex flex-col justify-center">
                    <label class="text-sm font-medium text-gray-700 mb-1">Target Node:</label>
                    <select id="target-select" class="p-2 border border-gray-300 rounded-md"></select>
                </div>
                
                <button onclick="simulateTransmission()" id="send-btn"
                        class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg shadow-md transition duration-150 text-center text-sm disabled:opacity-50">
                    Start Shortest Path Route
                </button>
                <button onclick="toggleLinkFailure()" id="fail-btn"
                        class="bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-4 rounded-lg shadow-md transition duration-150 text-center text-sm">
                    Simulate Link Failure (A-D)
                </button>
            </div>

            <h3 class="text-xl font-semibold text-gray-800 mb-3">Network Console Log</h3>
            <div id="mesh-log" class="console-log">
                <p class="log-info">Network is initialized. Select Source and Target nodes and click 'Start Shortest Path Route'.</p>
            </div>
        </div>
    </div>

    <script>
        const NODE_COUNT = 6;
        const NODE_IDS = Array.from({ length: NODE_COUNT }, (_, i) => String.fromCharCode(65 + i)); // A, B, C, D, E, F
        const MOVEMENT_SPEED_MS = 600;
        const LAYOUT_RADIUS = 180;
        const CENTER_POS = { x: 0, y: 0 }; // Will be calculated dynamically
        
        let animationLocked = false;
        let nodePositions = {}; // Stores calculated X, Y coordinates for each node
        let linkFailures = { 'A-D': false, 'D-A': false }; // Failure state for specific links

        // --- Utility Functions ---

        /** Logs a message to the console element */
        function log(message, type = 'log-info') {
            const consoleEl = document.getElementById('mesh-log');
            const timestamp = new Date().toLocaleTimeString('en-US', { hour12: false, second: '2-digit', minute: '2-digit' });
            consoleEl.innerHTML += `[${timestamp}] <span class="${type}">${message}</span>\n`;
            consoleEl.scrollTop = consoleEl.scrollHeight;
        }

        /** Pauses execution for a duration */
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
        
        /** Gets the canonical link ID (e.g., A-D or D-A always returns A-D) */
        function getLinkKey(id1, id2) {
            return id1 < id2 ? `${id1}-${id2}` : `${id2}-${id1}`;
        }

        // --- Core Visualization Setup ---

        /** Clears the visualization container and calculates node positions */
        function initializeVisualization() {
            const container = document.getElementById('mesh-vis');
            container.innerHTML = '';
            
            const { width, height } = container.getBoundingClientRect();
            
            // 1. Calculate Center Position
            CENTER_POS.x = width / 2;
            CENTER_POS.y = height / 2;

            // 2. Calculate and draw nodes 
            const angleStep = (2 * Math.PI) / NODE_COUNT;
            
            NODE_IDS.forEach((id, index) => {
                // Start at 12 o'clock and go clockwise
                const angle = index * angleStep - (Math.PI / 2); 
                
                // Calculate position on the circle
                const x = CENTER_POS.x + LAYOUT_RADIUS * Math.cos(angle);
                const y = CENTER_POS.y + LAYOUT_RADIUS * Math.sin(angle);
                
                nodePositions[id] = { x, y };
                
                // Draw Node
                const node = document.createElement('div');
                node.className = 'node';
                node.id = `node-${id}`;
                node.style.left = `${x - 32.5}px`; // Centered
                node.style.top = `${y - 32.5}px`; // Centered
                node.textContent = `Node ${id}`;
                node.onclick = () => selectNode(id);
                container.appendChild(node);
            });

            // 3. Draw all links (Full Mesh)
            for (let i = 0; i < NODE_COUNT; i++) {
                for (let j = i + 1; j < NODE_COUNT; j++) {
                    drawLink(NODE_IDS[i], NODE_IDS[j]);
                }
            }

            populateSelects();
        }

        /** Draws a connection line between two nodes */
        function drawLink(id1, id2) {
            const start = nodePositions[id1];
            const end = nodePositions[id2];
            
            const dx = end.x - start.x;
            const dy = end.y - start.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx) * (180 / Math.PI);
            
            const linkEl = document.createElement('div');
            linkEl.className = 'link';
            linkEl.id = `link-${getLinkKey(id1, id2)}`;
            linkEl.style.width = `${distance}px`;
            linkEl.style.left = `${start.x}px`;
            linkEl.style.top = `${start.y}px`;
            linkEl.style.transform = `rotate(${angle}deg)`;
            
            document.getElementById('mesh-vis').appendChild(linkEl);
            
            // Reapply failure status
            if (linkFailures[getLinkKey(id1, id2)]) {
                linkEl.classList.add('broken');
            }
        }

        /** Populates the source and target dropdowns */
        function populateSelects() {
            const sourceSelect = document.getElementById('source-select');
            const targetSelect = document.getElementById('target-select');

            sourceSelect.innerHTML = '';
            targetSelect.innerHTML = '';

            NODE_IDS.forEach(id => {
                sourceSelect.add(new Option(`Node ${id}`, id));
                targetSelect.add(new Option(`Node ${id}`, id));
            });

            // Set default selections
            sourceSelect.value = 'A';
            targetSelect.value = 'D';
            updateSelectedNodes();
            
            // Add change listeners
            sourceSelect.onchange = updateSelectedNodes;
            targetSelect.onchange = updateSelectedNodes;
        }

        /** Updates the visual style of the selected nodes */
        function updateSelectedNodes() {
            const sourceId = document.getElementById('source-select').value;
            const targetId = document.getElementById('target-select').value;

            document.querySelectorAll('.node').forEach(node => {
                node.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.3)';
                node.style.backgroundColor = '#059669'; // Default Green
            });

            const sourceEl = document.getElementById(`node-${sourceId}`);
            if (sourceEl) {
                sourceEl.style.backgroundColor = '#3b82f6'; // Blue for Source
                sourceEl.style.boxShadow = '0 0 10px #3b82f6';
            }
            
            const targetEl = document.getElementById(`node-${targetId}`);
            if (targetEl) {
                targetEl.style.backgroundColor = '#5e9605'; // Light Green for Target
                targetEl.style.boxShadow = '0 0 10px #34d399';
            }
        }
        
        /** Allows clicking a node to set it as source */
        function selectNode(id) {
            const sourceSelect = document.getElementById('source-select');
            sourceSelect.value = id;
            updateSelectedNodes();
        }

        /** Toggles the link failure state for the A-D link */
        function toggleLinkFailure() {
            const key = 'A-D';
            linkFailures[key] = !linkFailures[key];
            linkFailures['D-A'] = linkFailures[key]; // Mesh links are bidirectional
            
            const linkEl = document.getElementById(`link-${key}`);
            const failBtn = document.getElementById('fail-btn');

            if (linkFailures[key]) {
                linkEl.classList.add('broken');
                failBtn.textContent = 'Restore Link (A-D)';
                failBtn.classList.replace('bg-red-600', 'bg-green-600');
                failBtn.classList.replace('hover:bg-red-700', 'hover:bg-green-700');
                log('CRITICAL: Link A-D has failed. Routers must now recalculate the shortest path.', 'log-fail');
            } else {
                linkEl.classList.remove('broken');
                failBtn.textContent = 'Simulate Link Failure (A-D)';
                failBtn.classList.replace('bg-green-600', 'bg-red-600');
                failBtn.classList.replace('hover:bg-green-700', 'hover:bg-red-700');
                log('Link A-D restored. Direct path is now available again.', 'log-info');
            }
            
            // Clear any active link highlights
            document.querySelectorAll('.link').forEach(link => link.classList.remove('active'));
        }

        // --- Dijkstra's Algorithm (Simplified) ---
        
        /** Simplified Dijkstra's to find the shortest path in the mesh */
        function findShortestPath(startNode, endNode) {
            const graph = {};
            // 1. Build the adjacency list (cost is always 1 for this simulation)
            NODE_IDS.forEach(node => {
                graph[node] = {};
            });

            for (let i = 0; i < NODE_COUNT; i++) {
                for (let j = i + 1; j < NODE_COUNT; j++) {
                    const id1 = NODE_IDS[i];
                    const id2 = NODE_IDS[j];
                    const key = getLinkKey(id1, id2);

                    // Skip the link if it is failed
                    if (linkFailures[key]) continue; 

                    // Full mesh means direct link for cost of 1
                    graph[id1][id2] = 1;
                    graph[id2][id1] = 1;
                }
            }

            // 2. Dijkstra's core logic
            const distances = {};
            const previous = {};
            const nodes = [];

            // Initialization
            NODE_IDS.forEach(node => {
                distances[node] = Infinity;
                previous[node] = null;
                nodes.push(node);
            });
            distances[startNode] = 0;

            while (nodes.length) {
                // Find the node with the smallest distance
                nodes.sort((a, b) => distances[a] - distances[b]);
                const smallest = nodes.shift();

                if (smallest === endNode) break;

                if (distances[smallest] === Infinity) break;

                for (let neighbor in graph[smallest]) {
                    const alt = distances[smallest] + graph[smallest][neighbor];
                    if (alt < distances[neighbor]) {
                        distances[neighbor] = alt;
                        previous[neighbor] = smallest;
                    }
                }
            }

            // 3. Reconstruct path
            const path = [];
            let currentNode = endNode;
            while (currentNode) {
                path.unshift(currentNode);
                currentNode = previous[currentNode];
            }

            return path;
        }

        // --- Simulation Logic ---

        /** Simulates the data transmission process */
        async function simulateTransmission() {
            if (animationLocked) return;
            
            const sourceId = document.getElementById('source-select').value;
            const targetId = document.getElementById('target-select').value;
            
            if (sourceId === targetId) {
                log(`ERROR: Source and Target nodes must be different.`, 'log-fail');
                return;
            }

            // Clear any previous highlights
            document.querySelectorAll('.link').forEach(link => link.classList.remove('active'));

            // Find the shortest path
            const path = findShortestPath(sourceId, targetId);

            if (path.length <= 1) {
                 log(`ERROR: Could not find a path from ${sourceId} to ${targetId}. Check for link failures.`, 'log-fail');
                 return;
            }

            animationLocked = true;
            document.querySelectorAll('button').forEach(btn => btn.disabled = true);
            document.getElementById(`node-${sourceId}`).style.transform = 'scale(1.1)';

            
            log('-------------------------------------------', 'log-info');
            log(`START: Node ${sourceId} sends data to Node ${targetId}.`, 'log-send');
            log(`ROUTING: Shortest path calculated: ${path.join(' -> ')} (Cost: ${path.length - 1} hops).`, 'log-route');

            // 1. Create packet element
            const p = document.createElement('div');
            p.className = 'packet';
            p.style.left = `${nodePositions[sourceId].x - 7.5}px`;
            p.style.top = `${nodePositions[sourceId].y - 7.5}px`;
            document.getElementById('mesh-vis').appendChild(p);

            // 2. Traverse the path
            for (let i = 0; i < path.length - 1; i++) {
                const currentId = path[i];
                const nextId = path[i + 1];
                
                const startPos = nodePositions[currentId];
                const endPos = nodePositions[nextId];
                
                // Highlight the active link
                const linkKey = getLinkKey(currentId, nextId);
                const linkEl = document.getElementById(`link-${linkKey}`);
                if (linkEl) linkEl.classList.add('active');

                // Intermediate node logging
                if (i > 0) {
                    log(`Node ${currentId} receives the packet and FORWARDS it to Node ${nextId}.`, 'log-route');
                    document.getElementById(`node-${currentId}`).style.transform = 'scale(1.15)';
                    await sleep(300);
                    document.getElementById(`node-${currentId}`).style.transform = 'scale(1.0)';
                } else {
                    log(`Node ${currentId} initiates transmission to Node ${nextId}.`, 'log-send');
                }

                // Animate packet movement
                await movePacket(p, startPos, endPos, MOVEMENT_SPEED_MS);
                
                // Remove link highlight after movement
                if (linkEl) linkEl.classList.remove('active');
            }

            // 3. Target Node action
            document.getElementById(`node-${targetId}`).style.transform = 'scale(1.2)';
            log(`SUCCESS: Node ${targetId} receives the data. Connection successful.`, 'log-accept');
            p.style.backgroundColor = '#facc35'; // Green success color
            
            await sleep(1000);
            
            // 4. Cleanup and unlock
            p.remove();
            document.getElementById(`node-${sourceId}`).style.transform = 'scale(1.0)';
            document.getElementById(`node-${targetId}`).style.transform = 'scale(1.0)';
                
            log(`END: Transmission complete.`, 'log-info');
            animationLocked = false;
            document.querySelectorAll('button').forEach(btn => btn.disabled = false);
        }

        /** Animates a packet from one node position to the next */
        function movePacket(element, startPos, endPos, duration) {
            return new Promise(resolve => {
                element.style.transition = `all ${duration / 1000}s ease-in-out`;
                
                const dx = endPos.x - startPos.x;
                const dy = endPos.y - startPos.y;
                
                const offsetX = -7.5; // Centering adjustment
                const offsetY = -7.5; 

                // Use a slight delay to ensure the transition is picked up
                setTimeout(() => {
                    element.style.left = `${endPos.x + offsetX}px`;
                    element.style.top = `${endPos.y + offsetY}px`;
                }, 50); 
                
                setTimeout(() => {
                    resolve();
                }, duration);
            });
        }

        // --- Event Listeners and Initial Setup ---
        
        window.addEventListener('load', initializeVisualization);
        window.addEventListener('resize', initializeVisualization);
    </script>
</body>
</html>